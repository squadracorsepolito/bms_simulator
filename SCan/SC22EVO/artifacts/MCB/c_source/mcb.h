/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.5 Thu Jul 11 14:14:10 2024.
 */

#ifndef MCB_H
#define MCB_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define MCB_SENS_FRONT_1_FRAME_ID (0x05u)
#define MCB_SENS_FRONT_2_FRAME_ID (0x10u)
#define MCB_SENS_REAR_1_FRAME_ID (0x11u)
#define MCB_TLB_BATTERY_SHUT_STATUS_FRAME_ID (0x12u)
#define MCB_TLB_BATTERY_TSAL_STATUS_FRAME_ID (0x13u)
#define MCB_BMSLV_HELO_FRAME_ID (0x14u)
#define MCB_SENS_FRONT_HELO_FRAME_ID (0x15u)
#define MCB_SENS_REAR_HELO_FRAME_ID (0x16u)
#define MCB_STEERING_HELO_FRAME_ID (0x17u)
#define MCB_TLB_BATTERY_HELO_FRAME_ID (0x18u)
#define MCB_D_SPAXE_HELO_FRAME_ID (0x19u)
#define MCB_D_SPACE_RTD_ACK_FRAME_ID (0x25u)
#define MCB_STEERING_RTD_FRAME_ID (0x26u)
#define MCB_SENS_REAR_SHUTDOWN_STATUS_FRAME_ID (0x30u)
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_FRAME_ID (0x31u)
#define MCB_BMSLV_RELAY_OVERRIDE_FRAME_ID (0xffu)
#define MCB_BMSLV_CELL_VOLTAGE1_FRAME_ID (0x100u)
#define MCB_BMSLV_CELL_VOLTAGE2_FRAME_ID (0x101u)
#define MCB_BMSLV_BATTERY_PACK_GENERAL_FRAME_ID (0x102u)
#define MCB_BMSLV_STATUS_FRAME_ID (0x103u)
#define MCB_BMSLV_TEMP1_FRAME_ID (0x104u)
#define MCB_BMSLV_TEMP2_FRAME_ID (0x105u)
#define MCB_SENS_FRONT_3_FRAME_ID (0x120u)
#define MCB_SENS_REAR_3_FRAME_ID (0x121u)
#define MCB_D_SPACE_PERIPHERALS_CTRL_FRAME_ID (0x200u)
#define MCB_SENS_FRONT_NTC_FRAME_ID (0x400u)
#define MCB_SENS_REAR_NTC_FRAME_ID (0x401u)
#define MCB_SENS_REAR_2_FRAME_ID (0x402u)
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_FRAME_ID (0x500u)

/* Frame lengths in bytes. */
#define MCB_SENS_FRONT_1_LENGTH (8u)
#define MCB_SENS_FRONT_2_LENGTH (6u)
#define MCB_SENS_REAR_1_LENGTH (6u)
#define MCB_TLB_BATTERY_SHUT_STATUS_LENGTH (3u)
#define MCB_TLB_BATTERY_TSAL_STATUS_LENGTH (3u)
#define MCB_BMSLV_HELO_LENGTH (8u)
#define MCB_SENS_FRONT_HELO_LENGTH (8u)
#define MCB_SENS_REAR_HELO_LENGTH (8u)
#define MCB_STEERING_HELO_LENGTH (8u)
#define MCB_TLB_BATTERY_HELO_LENGTH (8u)
#define MCB_D_SPAXE_HELO_LENGTH (8u)
#define MCB_D_SPACE_RTD_ACK_LENGTH (1u)
#define MCB_STEERING_RTD_LENGTH (1u)
#define MCB_SENS_REAR_SHUTDOWN_STATUS_LENGTH (1u)
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_LENGTH (1u)
#define MCB_BMSLV_RELAY_OVERRIDE_LENGTH (2u)
#define MCB_BMSLV_CELL_VOLTAGE1_LENGTH (8u)
#define MCB_BMSLV_CELL_VOLTAGE2_LENGTH (6u)
#define MCB_BMSLV_BATTERY_PACK_GENERAL_LENGTH (6u)
#define MCB_BMSLV_STATUS_LENGTH (4u)
#define MCB_BMSLV_TEMP1_LENGTH (8u)
#define MCB_BMSLV_TEMP2_LENGTH (8u)
#define MCB_SENS_FRONT_3_LENGTH (8u)
#define MCB_SENS_REAR_3_LENGTH (8u)
#define MCB_D_SPACE_PERIPHERALS_CTRL_LENGTH (3u)
#define MCB_SENS_FRONT_NTC_LENGTH (8u)
#define MCB_SENS_REAR_NTC_LENGTH (8u)
#define MCB_SENS_REAR_2_LENGTH (4u)
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_LENGTH (1u)

/* Extended or standard frame types. */
#define MCB_SENS_FRONT_1_IS_EXTENDED (0)
#define MCB_SENS_FRONT_2_IS_EXTENDED (0)
#define MCB_SENS_REAR_1_IS_EXTENDED (0)
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_EXTENDED (0)
#define MCB_TLB_BATTERY_TSAL_STATUS_IS_EXTENDED (0)
#define MCB_BMSLV_HELO_IS_EXTENDED (0)
#define MCB_SENS_FRONT_HELO_IS_EXTENDED (0)
#define MCB_SENS_REAR_HELO_IS_EXTENDED (0)
#define MCB_STEERING_HELO_IS_EXTENDED (0)
#define MCB_TLB_BATTERY_HELO_IS_EXTENDED (0)
#define MCB_D_SPAXE_HELO_IS_EXTENDED (0)
#define MCB_D_SPACE_RTD_ACK_IS_EXTENDED (0)
#define MCB_STEERING_RTD_IS_EXTENDED (0)
#define MCB_SENS_REAR_SHUTDOWN_STATUS_IS_EXTENDED (0)
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_IS_EXTENDED (0)
#define MCB_BMSLV_RELAY_OVERRIDE_IS_EXTENDED (0)
#define MCB_BMSLV_CELL_VOLTAGE1_IS_EXTENDED (0)
#define MCB_BMSLV_CELL_VOLTAGE2_IS_EXTENDED (0)
#define MCB_BMSLV_BATTERY_PACK_GENERAL_IS_EXTENDED (0)
#define MCB_BMSLV_STATUS_IS_EXTENDED (0)
#define MCB_BMSLV_TEMP1_IS_EXTENDED (0)
#define MCB_BMSLV_TEMP2_IS_EXTENDED (0)
#define MCB_SENS_FRONT_3_IS_EXTENDED (0)
#define MCB_SENS_REAR_3_IS_EXTENDED (0)
#define MCB_D_SPACE_PERIPHERALS_CTRL_IS_EXTENDED (0)
#define MCB_SENS_FRONT_NTC_IS_EXTENDED (0)
#define MCB_SENS_REAR_NTC_IS_EXTENDED (0)
#define MCB_SENS_REAR_2_IS_EXTENDED (0)
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define MCB_SENS_FRONT_1_NAME "Sens_Front_1"
#define MCB_SENS_FRONT_2_NAME "Sens_Front_2"
#define MCB_SENS_REAR_1_NAME "Sens_Rear_1"
#define MCB_TLB_BATTERY_SHUT_STATUS_NAME "TLB_Battery_ShutStatus"
#define MCB_TLB_BATTERY_TSAL_STATUS_NAME "TLB_Battery_TSALStatus"
#define MCB_BMSLV_HELO_NAME "BMSLV_Helo"
#define MCB_SENS_FRONT_HELO_NAME "Sens_Front_Helo"
#define MCB_SENS_REAR_HELO_NAME "Sens_Rear_Helo"
#define MCB_STEERING_HELO_NAME "Steering_Helo"
#define MCB_TLB_BATTERY_HELO_NAME "TLB_Battery_Helo"
#define MCB_D_SPAXE_HELO_NAME "dSpaxe_Helo"
#define MCB_D_SPACE_RTD_ACK_NAME "dSpace_RTD_ACK"
#define MCB_STEERING_RTD_NAME "Steering_RTD"
#define MCB_SENS_REAR_SHUTDOWN_STATUS_NAME "Sens_Rear_ShutdownStatus"
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_NAME "Sens_Front_ShutdownStatus"
#define MCB_BMSLV_RELAY_OVERRIDE_NAME "BMSLV_RelayOverride"
#define MCB_BMSLV_CELL_VOLTAGE1_NAME "BMSLV_CellVoltage1"
#define MCB_BMSLV_CELL_VOLTAGE2_NAME "BMSLV_CellVoltage2"
#define MCB_BMSLV_BATTERY_PACK_GENERAL_NAME "BMSLV_BatteryPackGeneral"
#define MCB_BMSLV_STATUS_NAME "BMSLV_Status"
#define MCB_BMSLV_TEMP1_NAME "BMSLV_Temp1"
#define MCB_BMSLV_TEMP2_NAME "BMSLV_Temp2"
#define MCB_SENS_FRONT_3_NAME "Sens_Front_3"
#define MCB_SENS_REAR_3_NAME "Sens_Rear_3"
#define MCB_D_SPACE_PERIPHERALS_CTRL_NAME "dSpace_PeripheralsCTRL"
#define MCB_SENS_FRONT_NTC_NAME "Sens_Front_NTC"
#define MCB_SENS_REAR_NTC_NAME "Sens_Rear_NTC"
#define MCB_SENS_REAR_2_NAME "Sens_Rear_2"
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_NAME "Steering_MotorControl_Debug"

/* Signal Names. */
#define MCB_SENS_FRONT_1_THROTTLE_0_VOLTAGE_M_V_NAME "Throttle_0_Voltage_mV"
#define MCB_SENS_FRONT_1_THROTTLE_1_VOLTAGE_M_V_NAME "Throttle_1_Voltage_mV"
#define MCB_SENS_FRONT_1_STEERING_VOLTAGE_M_V_NAME "Steering_Voltage_mV"
#define MCB_SENS_FRONT_1_BRAKE_STRAINGAUGE_VOLTAGE_M_V_NAME "Brake_Straingauge_Voltage_mV"
#define MCB_SENS_FRONT_2_POT_FL_VOLTAGE_M_V_NAME "Pot_FL_Voltage_mV"
#define MCB_SENS_FRONT_2_POT_FR_VOLTAGE_M_V_NAME "Pot_FR_Voltage_mV"
#define MCB_SENS_FRONT_2_BRAKE_PRESSURE_VOLTAGE_M_V_NAME "BrakePressure_Voltage_mV"
#define MCB_SENS_REAR_1_POT_RL_VOLTAGE_M_V_NAME "Pot_RL_Voltage_mV"
#define MCB_SENS_REAR_1_POT_RR_VOLTAGE_RR_NAME "Pot_RR_Voltage_RR"
#define MCB_SENS_REAR_1_BRAKE_PRESSURE_REAR_VOLTAGE_M_V_NAME "BrakePressure_Rear_Voltage_mV"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_SHUT_CLOSED_PRE_AMS_IMD_LATCH_NAME "isShutClosed_preAMS_IMD_Latch"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_SHUT_CLOSED_POST_AMS_LATCH_NAME "isShutClosed_postAMSLatch"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_SHUT_CLOSED_POST_IMD_LATCH_NAME "isShutClosed_postIMDLatch"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_SHUTDOWN_CLOSED_PRE_TLB_BATT_FINAL_NAME "isShutdownClosed_preTLBBattFinal"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_AMS_ERROR_LATCHED_NAME "isAMSErrorLatched"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_IMD_ERROR_LATCHED_NAME "isIMDErrorLatched"
#define MCB_TLB_BATTERY_SHUT_STATUS_IS_SD_PRCH_RLY_CLOSED_NAME "isSdPrchRlyClosed"
#define MCB_TLB_BATTERY_SHUT_STATUS_SHUTDOWN_ADC_POST_SD_PRECHARGE_RELAY_NAME "ShutdownADC_postSDPrechargeRelay"
#define MCB_TLB_BATTERY_SHUT_STATUS_SHUTDOWN_ADC_AI_RS_OPENING_DELAY_CAPS_NAME "ShutdownADC_AIRsOpeningDelayCaps"
#define MCB_TLB_BATTERY_TSAL_STATUS_TSAL_IS_GREEN_ON_NAME "TSAL_isGreenON"
#define MCB_TLB_BATTERY_TSAL_STATUS_TSAL_IS_AIR_POS_CLOSED_NAME "TSAL_isAIRPosClosed"
#define MCB_TLB_BATTERY_TSAL_STATUS_TSAL_IS_AIR_NEG_CLOSED_NAME "TSAL_IsAIRNegClosed"
#define MCB_TLB_BATTERY_TSAL_STATUS_TSAL_IS_RELAY_PRECHARGE_CLOSED_NAME "TSAL_IsRelayPrechargeClosed"
#define MCB_TLB_BATTERY_TSAL_STATUS_TSAL_IS_DC_BUS_OVER60_V_NAME "TSAL_isDCBusOver60V"
#define MCB_TLB_BATTERY_TSAL_STATUS_INTENTIONAL_STATE_AIR_POS_NAME "IntentionalState_AIRPos"
#define MCB_TLB_BATTERY_TSAL_STATUS_INTENTIONAL_STATE_AIR_NEG_NAME "IntentionalState_AIRNeg"
#define MCB_TLB_BATTERY_TSAL_STATUS_INTENTIONAL_STATE_RELAY_PRECHARGE_NAME "IntentionalState_RelayPrecharge"
#define MCB_TLB_BATTERY_TSAL_STATUS_SCS_SHORT2_GND_AIR_POS_NAME "SCS_Short2GND_AirPos"
#define MCB_TLB_BATTERY_TSAL_STATUS_SCS_SHORT2_GND_AIR_NEG_NAME "SCS_Short2GND_AirNeg"
#define MCB_TLB_BATTERY_TSAL_STATUS_SCS_IS_ANY_SHORT2_GND_PRESENT_NAME "SCS_isAnyShort2GND_Present"
#define MCB_TLB_BATTERY_TSAL_STATUS_IMP_IS_ANY_IMP_PRESENT_NAME "Imp_isAnyImp_Present"
#define MCB_TLB_BATTERY_TSAL_STATUS_IMP_IS_AIR_POS_IMP_PRESENT_NAME "Imp_isAIRPosImp_Present"
#define MCB_TLB_BATTERY_TSAL_STATUS_IMP_IS_AIR_NEG_IMP_PRESENT_NAME "Imp_isAIRNegImp_Present"
#define MCB_TLB_BATTERY_TSAL_STATUS_IMP_IS_RELAY_PRECHARGE_IMP_PRESENT_NAME "Imp_isRelayPrechargeImp_Present"
#define MCB_TLB_BATTERY_TSAL_STATUS_IMP_IS_DC_BUS_VOLTAGE_IMP_PRESENT_NAME "Imp_isDCBusVoltageImp_Present"
#define MCB_TLB_BATTERY_TSAL_STATUS_IMP_IS_ANY_IMP_LATCHED_NAME "Imp_isAnyImp_Latched"
#define MCB_BMSLV_HELO_TIME_NAME "time"
#define MCB_SENS_FRONT_HELO_TIME_NAME "time"
#define MCB_SENS_REAR_HELO_TIME_NAME "time"
#define MCB_STEERING_HELO_TIME_NAME "time"
#define MCB_TLB_BATTERY_HELO_TIME_NAME "time"
#define MCB_D_SPAXE_HELO_TIME_NAME "time"
#define MCB_D_SPACE_RTD_ACK_RTD_FSM_STATE_NAME "RTD_FSM_STATE"
#define MCB_STEERING_RTD_RTD_CMD_NAME "RTD_CMD"
#define MCB_SENS_REAR_SHUTDOWN_STATUS_IS_SHUT_CLOSED_POST_BSPD_NAME "isShutClosed_postBSPD"
#define MCB_SENS_REAR_SHUTDOWN_STATUS_IS_SHUT_CLOSED_PRE_FUNGHI_NAME "isShutClosed_preFunghi"
#define MCB_SENS_REAR_SHUTDOWN_STATUS_IS_SHUT_CLOSED_POST_INV_MONO_NAME "isShutClosed_postInvMono"
#define MCB_SENS_REAR_SHUTDOWN_STATUS_IS_SHUT_CLOSED_POST_INV_FR_NAME "isShutClosed_postInvFR"
#define MCB_SENS_REAR_SHUTDOWN_STATUS_IS_BSP_DIN_ERROR_NAME "isBSPDinError"
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_IS_SHUT_CLOSED_PRE_INERTIA_NAME "isShutClosed_preInertia"
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_IS_SHUT_CLOSED_POST_INERTIA_NAME "isShutClosed_postInertia"
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_IS_SHUT_CLOSED_POST_BOTS_NAME "isShutClosed_postBOTS"
#define MCB_SENS_FRONT_SHUTDOWN_STATUS_IS_SHUT_CLOSED_POST_COCKPIT_NAME "isShutClosed_postCockpit"
#define MCB_BMSLV_RELAY_OVERRIDE_PASSWORD_NAME "password"
#define MCB_BMSLV_RELAY_OVERRIDE_CLOSE_RELAY_NAME "close_relay"
#define MCB_BMSLV_CELL_VOLTAGE1_CELL_1_VOLTAGE_M_V_NAME "Cell_1_Voltage_mV"
#define MCB_BMSLV_CELL_VOLTAGE1_CELL_2_VOLTAGE_M_V_NAME "Cell_2_Voltage_mV"
#define MCB_BMSLV_CELL_VOLTAGE1_CELL_3_VOLTAGE_M_V_NAME "Cell_3_Voltage_mV"
#define MCB_BMSLV_CELL_VOLTAGE1_CELL_4_VOLTAGE_M_V_NAME "Cell_4_Voltage_mV"
#define MCB_BMSLV_CELL_VOLTAGE2_CELL_5_VOLTAGE_M_V_NAME "Cell_5_Voltage_mV"
#define MCB_BMSLV_CELL_VOLTAGE2_CELL_6_VOLTAGE_M_V_NAME "Cell_6_Voltage_mV"
#define MCB_BMSLV_CELL_VOLTAGE2_CELL_7_VOLTAGE_M_V_NAME "Cell_7_Voltage_mV"
#define MCB_BMSLV_BATTERY_PACK_GENERAL_CURRENT_SENSOR_M_V_NAME "Current_Sensor_mV"
#define MCB_BMSLV_BATTERY_PACK_GENERAL_LV_TOTAL_VOLTAGE_M_V_NAME "LV_Total_Voltage_mV"
#define MCB_BMSLV_BATTERY_PACK_GENERAL_LV_TOTAL_VOLTAGE_SUM_M_V_NAME "LV_Total_Voltage_Sum_mV"
#define MCB_BMSLV_STATUS_IS_RELAY_OPEN_NAME "isRelayOpen"
#define MCB_BMSLV_STATUS_CELL1_OV_NAME "cell1_OV"
#define MCB_BMSLV_STATUS_CELL2_OV_NAME "cell2_OV"
#define MCB_BMSLV_STATUS_CELL3_OV_NAME "cell3_OV"
#define MCB_BMSLV_STATUS_CELL4_OV_NAME "cell4_OV"
#define MCB_BMSLV_STATUS_CELL5_OV_NAME "cell5_OV"
#define MCB_BMSLV_STATUS_CELL6_OV_NAME "cell6_OV"
#define MCB_BMSLV_STATUS_CELL7_OV_NAME "cell7_OV"
#define MCB_BMSLV_STATUS_CELL1_UV_NAME "cell1_UV"
#define MCB_BMSLV_STATUS_CELL2_UV_NAME "cell2_UV"
#define MCB_BMSLV_STATUS_CELL3_UV_NAME "cell3_UV"
#define MCB_BMSLV_STATUS_CELL4_UV_NAME "cell4_UV"
#define MCB_BMSLV_STATUS_CELL5_UV_NAME "cell5_UV"
#define MCB_BMSLV_STATUS_CELL6_UV_NAME "cell6_UV"
#define MCB_BMSLV_STATUS_CELL7_UV_NAME "cell7_UV"
#define MCB_BMSLV_STATUS_TEMP1_OT_NAME "temp1_OT"
#define MCB_BMSLV_STATUS_TEMP2_OT_NAME "temp2_OT"
#define MCB_BMSLV_STATUS_TEMP3_OT_NAME "temp3_OT"
#define MCB_BMSLV_STATUS_TEMP4_OT_NAME "temp4_OT"
#define MCB_BMSLV_STATUS_TEMP5_OT_NAME "temp5_OT"
#define MCB_BMSLV_STATUS_TEMP6_OT_NAME "temp6_OT"
#define MCB_BMSLV_STATUS_TEMP7_OT_NAME "temp7_OT"
#define MCB_BMSLV_STATUS_TEMP8_OT_NAME "temp8_OT"
#define MCB_BMSLV_STATUS_TEMP9_OT_NAME "temp9_OT"
#define MCB_BMSLV_STATUS_TEMP10_OT_NAME "temp10_OT"
#define MCB_BMSLV_STATUS_TEMP11_OT_NAME "temp11_OT"
#define MCB_BMSLV_STATUS_TEMP12_OT_NAME "temp12_OT"
#define MCB_BMSLV_TEMP1_NTC1_RESISTANCE_NAME "NTC1_Resistance"
#define MCB_BMSLV_TEMP1_NTC2_RESISTANCE_NAME "NTC2_Resistance"
#define MCB_BMSLV_TEMP1_NTC3_RESISTANCE_NAME "NTC3_Resistance"
#define MCB_BMSLV_TEMP1_NTC4_RESISTANCE_NAME "NTC4_Resistance"
#define MCB_BMSLV_TEMP1_NTC5_RESISTANCE_NAME "NTC5_Resistance"
#define MCB_BMSLV_TEMP1_NTC6_RESISTANCE_NAME "NTC6_Resistance"
#define MCB_BMSLV_TEMP2_NTC1_RESISTANCE_NAME "NTC1_Resistance"
#define MCB_BMSLV_TEMP2_NTC2_RESISTANCE_NAME "NTC2_Resistance"
#define MCB_BMSLV_TEMP2_NTC3_RESISTANCE_NAME "NTC3_Resistance"
#define MCB_BMSLV_TEMP2_NTC4_RESISTANCE_NAME "NTC4_Resistance"
#define MCB_BMSLV_TEMP2_NTC5_RESISTANCE_NAME "NTC5_Resistance"
#define MCB_BMSLV_TEMP2_NTC6_RESISTANCE_NAME "NTC6_Resistance"
#define MCB_SENS_FRONT_3_STRAINGAUGE_PUSH_FR_VOLTAGE_M_V_NAME "Straingauge_PushFR_Voltage_mV"
#define MCB_SENS_FRONT_3_STRAINGAUGE_TIE_FR_VOLTAGE_M_V_NAME "Straingauge_TieFR_Voltage_mV"
#define MCB_SENS_FRONT_3_STRAINGAUGE_PUSH_FL_VOLTAGE_M_V_NAME "Straingauge_PushFL_Voltage_mV"
#define MCB_SENS_FRONT_3_STRAINGAUGE_TIE_FL_VOLTAGE_M_V_NAME "Straingauge_TieFL_Voltage_mV"
#define MCB_SENS_REAR_3_STRAINGAUGE_PUSH_RR_VOLTAGE_M_V_NAME "Straingauge_PushRR_Voltage_mV"
#define MCB_SENS_REAR_3_STRAINGAUGE_TIE_RR_VOLTAGE_M_V_NAME "Straingauge_TieRR_Voltage_mV"
#define MCB_SENS_REAR_3_STRAINGAUGE_PUSH_RL_VOLTAGE_M_V_NAME "Straingauge_PushRL_Voltage_mV"
#define MCB_SENS_REAR_3_STRAINGAUGE_TIE_RL_VOLTAGE_M_V_NAME "Straingauge_TieRL_Voltage_mV"
#define MCB_D_SPACE_PERIPHERALS_CTRL_BRAKE_LIGHT_ON_CTRL_NAME "BrakeLightON_CTRL"
#define MCB_D_SPACE_PERIPHERALS_CTRL_RAD_FAN_PWM_CTRL_NAME "RadFAN_PWM_CTRL"
#define MCB_D_SPACE_PERIPHERALS_CTRL_BATT_HV_FAN_CTRL_NAME "BattHVFan_CTRL"
#define MCB_SENS_FRONT_NTC_NTC_1_RESISTANCE_NAME "NTC_1_Resistance"
#define MCB_SENS_FRONT_NTC_NTC_2_RESISTANCE_NAME "NTC_2_Resistance"
#define MCB_SENS_FRONT_NTC_NTC_3_RESISTANCE_NAME "NTC_3_Resistance"
#define MCB_SENS_FRONT_NTC_NTC_4_RESISTANCE_NAME "NTC_4_Resistance"
#define MCB_SENS_FRONT_NTC_NTC_SPARE1_RESISTANCE_NAME "NTC_Spare1_Resistance"
#define MCB_SENS_FRONT_NTC_NTC_SPARE2_RESISTANCE_NAME "NTC_Spare2_Resistance"
#define MCB_SENS_REAR_NTC_NTC_1_RESISTANCE_NAME "NTC_1_Resistance"
#define MCB_SENS_REAR_NTC_NTC_2_RESISTANCE_NAME "NTC_2_Resistance"
#define MCB_SENS_REAR_NTC_NTC_3_RESISTANCE_NAME "NTC_3_Resistance"
#define MCB_SENS_REAR_NTC_NTC_4_RESISTANCE_NAME "NTC_4_Resistance"
#define MCB_SENS_REAR_NTC_NTC_5_RESISTANCE_NAME "NTC_5_Resistance"
#define MCB_SENS_REAR_NTC_NTC_6_RESISTANCE_NAME "NTC_6_Resistance"
#define MCB_SENS_REAR_2_COOLING_PRESSURE_DX_VOLTAGE_M_V_NAME "CoolingPressure_DX_Voltage_mV"
#define MCB_SENS_REAR_2_COOLING_PRESSURE_SX_VOLTAGE_M_V_NAME "CoolingPressure_SX_Voltage_mV"
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_FRONT_LEFT_ON_NAME "FrontLeft_ON"
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_FRONT_RIGHT_ON_NAME "FrontRight_ON"
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_REAR_LEFT_ON_NAME "RearLeft_ON"
#define MCB_STEERING_MOTOR_CONTROL_DEBUG_REAR_RIGHT_ON_NAME "RearRight_ON"

/**
 * Signals in message Sens_Front_1.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_front_1_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t throttle_0_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t throttle_1_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_straingauge_voltage_m_v;
};

/**
 * Signals in message Sens_Front_2.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_front_2_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pot_fl_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pot_fr_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure_voltage_m_v;
};

/**
 * Signals in message Sens_Rear_1.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_rear_1_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pot_rl_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pot_rr_voltage_rr;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure_rear_voltage_m_v;
};

/**
 * Signals in message TLB_Battery_ShutStatus.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_battery_shut_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_shut_closed_pre_ams_imd_latch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_shut_closed_post_ams_latch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_shut_closed_post_imd_latch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_shutdown_closed_pre_tlb_batt_final;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_ams_error_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_imd_error_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_sd_prch_rly_closed;

    /**
     * Range: 0..2179 (0..255 V)
     * Scale: 0.117
     * Offset: 0
     */
    uint8_t shutdown_adc_post_sd_precharge_relay;

    /**
     * Range: 0..2179 (0..255 V)
     * Scale: 0.117
     * Offset: 0
     */
    uint8_t shutdown_adc_ai_rs_opening_delay_caps;
};

/**
 * Signals in message TLB_Battery_TSALStatus.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_battery_tsal_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_is_green_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_is_air_pos_closed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_is_air_neg_closed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_is_relay_precharge_closed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_is_dc_bus_over60_v;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t intentional_state_air_pos;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t intentional_state_air_neg;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t intentional_state_relay_precharge;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t scs_short2_gnd_air_pos;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t scs_short2_gnd_air_neg;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t scs_is_any_short2_gnd_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_is_any_imp_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_is_air_pos_imp_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_is_air_neg_imp_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_is_relay_precharge_imp_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_is_dc_bus_voltage_imp_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_is_any_imp_latched;
};

/**
 * Signals in message BMSLV_Helo.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_helo_t {
    /**
     * Range: 0..18446744073709552000 (0..18446744073709552000 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t time;
};

/**
 * Signals in message Sens_Front_Helo.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_front_helo_t {
    /**
     * Range: 0..18446744073709552000 (0..18446744073709552000 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t time;
};

/**
 * Signals in message Sens_Rear_Helo.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_rear_helo_t {
    /**
     * Range: 0..18446744073709552000 (0..18446744073709552000 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t time;
};

/**
 * Signals in message Steering_Helo.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_steering_helo_t {
    /**
     * Range: 0..18446744073709552000 (0..18446744073709552000 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t time;
};

/**
 * Signals in message TLB_Battery_Helo.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_battery_helo_t {
    /**
     * Range: 0..18446744073709552000 (0..18446744073709552000 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t time;
};

/**
 * Signals in message dSpaxe_Helo.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_d_spaxe_helo_t {
    /**
     * Range: 0..18446744073709552000 (0..18446744073709552000 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t time;
};

/**
 * Signals in message dSpace_RTD_ACK.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_d_space_rtd_ack_t {
    /**
     * Range: -1..6 (-1..6 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rtd_fsm_state;
};

/**
 * Signals in message Steering_RTD.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_steering_rtd_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtd_cmd;
};

/**
 * Signals in message Sens_Rear_ShutdownStatus.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_rear_shutdown_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_post_bspd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_pre_funghi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_post_inv_mono;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_post_inv_fr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_bsp_din_error;
};

/**
 * Signals in message Sens_Front_ShutdownStatus.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_front_shutdown_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_pre_inertia;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_post_inertia;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_post_bots;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t is_shut_closed_post_cockpit;
};

/**
 * Signals in message BMSLV_RelayOverride.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_relay_override_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t password;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t close_relay;
};

/**
 * Signals in message BMSLV_CellVoltage1.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_cell_voltage1_t {
    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_1_voltage_m_v;

    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_2_voltage_m_v;

    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_3_voltage_m_v;

    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_4_voltage_m_v;
};

/**
 * Signals in message BMSLV_CellVoltage2.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_cell_voltage2_t {
    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_5_voltage_m_v;

    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_6_voltage_m_v;

    /**
     * Range: -52632..12903 (0..2490.33 -)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t cell_7_voltage_m_v;
};

/**
 * Signals in message BMSLV_BatteryPackGeneral.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_battery_pack_general_t {
    /**
     * Range: 0..65535 (0..4980.66 -)
     * Scale: 0.076
     * Offset: 0
     */
    uint16_t current_sensor_m_v;

    /**
     * Range: -52434..13101 (0..17497.845 -)
     * Scale: 0.267
     * Offset: 14000
     */
    uint16_t lv_total_voltage_m_v;

    /**
     * Range: -52434..13101 (0..17497.845 -)
     * Scale: 0.267
     * Offset: 14000
     */
    uint16_t lv_total_voltage_sum_m_v;
};

/**
 * Signals in message BMSLV_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_relay_open;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell1_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell2_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell3_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell4_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell5_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell6_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell7_ov;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell1_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell2_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell3_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell4_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell5_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell6_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cell7_uv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp1_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp2_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp3_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp4_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp5_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp6_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp7_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp8_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp9_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp10_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp11_ot;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp12_ot;
};

/**
 * Signals in message BMSLV_Temp1.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_temp1_t {
    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc1_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc2_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc3_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc4_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc5_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc6_resistance;
};

/**
 * Signals in message BMSLV_Temp2.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bmslv_temp2_t {
    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc1_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc2_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc3_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc4_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc5_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc6_resistance;
};

/**
 * Signals in message Sens_Front_3.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_front_3_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_push_fr_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_tie_fr_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_push_fl_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_tie_fl_voltage_m_v;
};

/**
 * Signals in message Sens_Rear_3.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_rear_3_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_push_rr_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_tie_rr_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_push_rl_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t straingauge_tie_rl_voltage_m_v;
};

/**
 * Signals in message dSpace_PeripheralsCTRL.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_d_space_peripherals_ctrl_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t brake_light_on_ctrl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rad_fan_pwm_ctrl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t batt_hv_fan_ctrl;
};

/**
 * Signals in message Sens_Front_NTC.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_front_ntc_t {
    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_1_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_2_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_3_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_4_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_spare1_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_spare2_resistance;
};

/**
 * Signals in message Sens_Rear_NTC.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_rear_ntc_t {
    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_1_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_2_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_3_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_4_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_5_resistance;

    /**
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t ntc_6_resistance;
};

/**
 * Signals in message Sens_Rear_2.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sens_rear_2_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cooling_pressure_dx_voltage_m_v;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cooling_pressure_sx_voltage_m_v;
};

/**
 * Signals in message Steering_MotorControl_Debug.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_steering_motor_control_debug_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t front_left_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t front_right_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rear_left_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rear_right_on;
};

/**
 * Pack message Sens_Front_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_front_1_pack(
    uint8_t *dst_p,
    const struct mcb_sens_front_1_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Front_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_front_1_unpack(
    struct mcb_sens_front_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Front_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_front_1_init(struct mcb_sens_front_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_1_throttle_0_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_1_throttle_0_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_1_throttle_0_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_1_throttle_1_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_1_throttle_1_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_1_throttle_1_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_1_steering_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_1_steering_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_1_steering_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_1_brake_straingauge_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_1_brake_straingauge_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_1_brake_straingauge_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message Sens_Front_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_front_2_pack(
    uint8_t *dst_p,
    const struct mcb_sens_front_2_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Front_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_front_2_unpack(
    struct mcb_sens_front_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Front_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_front_2_init(struct mcb_sens_front_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_2_pot_fl_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_2_pot_fl_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_2_pot_fl_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_2_pot_fr_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_2_pot_fr_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_2_pot_fr_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_2_brake_pressure_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_2_brake_pressure_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_2_brake_pressure_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message Sens_Rear_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_rear_1_pack(
    uint8_t *dst_p,
    const struct mcb_sens_rear_1_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Rear_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_rear_1_unpack(
    struct mcb_sens_rear_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Rear_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_rear_1_init(struct mcb_sens_rear_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_1_pot_rl_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_1_pot_rl_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_1_pot_rl_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_1_pot_rr_voltage_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_1_pot_rr_voltage_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_1_pot_rr_voltage_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_1_brake_pressure_rear_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_1_brake_pressure_rear_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_1_brake_pressure_rear_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message TLB_Battery_ShutStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_battery_shut_status_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_battery_shut_status_t *src_p,
    size_t size);

/**
 * Unpack message TLB_Battery_ShutStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_battery_shut_status_unpack(
    struct mcb_tlb_battery_shut_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_Battery_ShutStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_battery_shut_status_init(struct mcb_tlb_battery_shut_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_shut_closed_pre_ams_imd_latch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_shut_closed_pre_ams_imd_latch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_shut_closed_pre_ams_imd_latch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_shut_closed_post_ams_latch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_shut_closed_post_ams_latch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_shut_closed_post_ams_latch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_shut_closed_post_imd_latch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_shut_closed_post_imd_latch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_shut_closed_post_imd_latch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_shutdown_closed_pre_tlb_batt_final_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_shutdown_closed_pre_tlb_batt_final_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_shutdown_closed_pre_tlb_batt_final_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_ams_error_latched_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_ams_error_latched_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_ams_error_latched_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_imd_error_latched_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_imd_error_latched_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_imd_error_latched_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_is_sd_prch_rly_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_is_sd_prch_rly_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_is_sd_prch_rly_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_shutdown_adc_post_sd_precharge_relay_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_shutdown_adc_post_sd_precharge_relay_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_shutdown_adc_post_sd_precharge_relay_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_shut_status_shutdown_adc_ai_rs_opening_delay_caps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_shut_status_shutdown_adc_ai_rs_opening_delay_caps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_shut_status_shutdown_adc_ai_rs_opening_delay_caps_is_in_range(uint8_t value);

/**
 * Pack message TLB_Battery_TSALStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_battery_tsal_status_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_battery_tsal_status_t *src_p,
    size_t size);

/**
 * Unpack message TLB_Battery_TSALStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_battery_tsal_status_unpack(
    struct mcb_tlb_battery_tsal_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_Battery_TSALStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_battery_tsal_status_init(struct mcb_tlb_battery_tsal_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_tsal_is_green_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_tsal_is_green_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_tsal_is_green_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_tsal_is_air_pos_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_tsal_is_air_pos_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_tsal_is_air_pos_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_tsal_is_air_neg_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_tsal_is_air_neg_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_tsal_is_air_neg_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_tsal_is_relay_precharge_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_tsal_is_relay_precharge_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_tsal_is_relay_precharge_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_tsal_is_dc_bus_over60_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_tsal_is_dc_bus_over60_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_tsal_is_dc_bus_over60_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_intentional_state_air_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_intentional_state_air_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_intentional_state_air_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_intentional_state_air_neg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_intentional_state_air_neg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_intentional_state_air_neg_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_intentional_state_relay_precharge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_intentional_state_relay_precharge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_intentional_state_relay_precharge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_scs_short2_gnd_air_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_scs_short2_gnd_air_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_scs_short2_gnd_air_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_scs_short2_gnd_air_neg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_scs_short2_gnd_air_neg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_scs_short2_gnd_air_neg_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_scs_is_any_short2_gnd_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_scs_is_any_short2_gnd_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_scs_is_any_short2_gnd_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_imp_is_any_imp_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_imp_is_any_imp_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_imp_is_any_imp_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_imp_is_air_pos_imp_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_imp_is_air_pos_imp_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_imp_is_air_pos_imp_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_imp_is_air_neg_imp_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_imp_is_air_neg_imp_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_imp_is_air_neg_imp_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_imp_is_relay_precharge_imp_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_imp_is_relay_precharge_imp_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_imp_is_relay_precharge_imp_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_imp_is_dc_bus_voltage_imp_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_imp_is_dc_bus_voltage_imp_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_imp_is_dc_bus_voltage_imp_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_battery_tsal_status_imp_is_any_imp_latched_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_tsal_status_imp_is_any_imp_latched_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_tsal_status_imp_is_any_imp_latched_is_in_range(uint8_t value);

/**
 * Pack message BMSLV_Helo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_helo_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_helo_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_Helo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_helo_unpack(
    struct mcb_bmslv_helo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_Helo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_helo_init(struct mcb_bmslv_helo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_bmslv_helo_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_helo_time_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_helo_time_is_in_range(uint64_t value);

/**
 * Pack message Sens_Front_Helo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_front_helo_pack(
    uint8_t *dst_p,
    const struct mcb_sens_front_helo_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Front_Helo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_front_helo_unpack(
    struct mcb_sens_front_helo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Front_Helo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_front_helo_init(struct mcb_sens_front_helo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_sens_front_helo_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_helo_time_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_helo_time_is_in_range(uint64_t value);

/**
 * Pack message Sens_Rear_Helo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_rear_helo_pack(
    uint8_t *dst_p,
    const struct mcb_sens_rear_helo_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Rear_Helo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_rear_helo_unpack(
    struct mcb_sens_rear_helo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Rear_Helo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_rear_helo_init(struct mcb_sens_rear_helo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_sens_rear_helo_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_helo_time_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_helo_time_is_in_range(uint64_t value);

/**
 * Pack message Steering_Helo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_steering_helo_pack(
    uint8_t *dst_p,
    const struct mcb_steering_helo_t *src_p,
    size_t size);

/**
 * Unpack message Steering_Helo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_steering_helo_unpack(
    struct mcb_steering_helo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Steering_Helo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_steering_helo_init(struct mcb_steering_helo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_steering_helo_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_steering_helo_time_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_steering_helo_time_is_in_range(uint64_t value);

/**
 * Pack message TLB_Battery_Helo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_battery_helo_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_battery_helo_t *src_p,
    size_t size);

/**
 * Unpack message TLB_Battery_Helo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_battery_helo_unpack(
    struct mcb_tlb_battery_helo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_Battery_Helo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_battery_helo_init(struct mcb_tlb_battery_helo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_tlb_battery_helo_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_battery_helo_time_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_battery_helo_time_is_in_range(uint64_t value);

/**
 * Pack message dSpaxe_Helo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_d_spaxe_helo_pack(
    uint8_t *dst_p,
    const struct mcb_d_spaxe_helo_t *src_p,
    size_t size);

/**
 * Unpack message dSpaxe_Helo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_d_spaxe_helo_unpack(
    struct mcb_d_spaxe_helo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dSpaxe_Helo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_d_spaxe_helo_init(struct mcb_d_spaxe_helo_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_d_spaxe_helo_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_d_spaxe_helo_time_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_d_spaxe_helo_time_is_in_range(uint64_t value);

/**
 * Pack message dSpace_RTD_ACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_d_space_rtd_ack_pack(
    uint8_t *dst_p,
    const struct mcb_d_space_rtd_ack_t *src_p,
    size_t size);

/**
 * Unpack message dSpace_RTD_ACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_d_space_rtd_ack_unpack(
    struct mcb_d_space_rtd_ack_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dSpace_RTD_ACK.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_d_space_rtd_ack_init(struct mcb_d_space_rtd_ack_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_d_space_rtd_ack_rtd_fsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_d_space_rtd_ack_rtd_fsm_state_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_d_space_rtd_ack_rtd_fsm_state_is_in_range(int8_t value);

/**
 * Pack message Steering_RTD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_steering_rtd_pack(
    uint8_t *dst_p,
    const struct mcb_steering_rtd_t *src_p,
    size_t size);

/**
 * Unpack message Steering_RTD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_steering_rtd_unpack(
    struct mcb_steering_rtd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Steering_RTD.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_steering_rtd_init(struct mcb_steering_rtd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_steering_rtd_rtd_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_steering_rtd_rtd_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_steering_rtd_rtd_cmd_is_in_range(uint8_t value);

/**
 * Pack message Sens_Rear_ShutdownStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_rear_shutdown_status_pack(
    uint8_t *dst_p,
    const struct mcb_sens_rear_shutdown_status_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Rear_ShutdownStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_rear_shutdown_status_unpack(
    struct mcb_sens_rear_shutdown_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Rear_ShutdownStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_rear_shutdown_status_init(struct mcb_sens_rear_shutdown_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_rear_shutdown_status_is_shut_closed_post_bspd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_shutdown_status_is_shut_closed_post_bspd_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_shutdown_status_is_shut_closed_post_bspd_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_rear_shutdown_status_is_shut_closed_pre_funghi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_shutdown_status_is_shut_closed_pre_funghi_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_shutdown_status_is_shut_closed_pre_funghi_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_rear_shutdown_status_is_shut_closed_post_inv_mono_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_shutdown_status_is_shut_closed_post_inv_mono_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_shutdown_status_is_shut_closed_post_inv_mono_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_rear_shutdown_status_is_shut_closed_post_inv_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_shutdown_status_is_shut_closed_post_inv_fr_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_shutdown_status_is_shut_closed_post_inv_fr_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_rear_shutdown_status_is_bsp_din_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_shutdown_status_is_bsp_din_error_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_shutdown_status_is_bsp_din_error_is_in_range(int8_t value);

/**
 * Pack message Sens_Front_ShutdownStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_front_shutdown_status_pack(
    uint8_t *dst_p,
    const struct mcb_sens_front_shutdown_status_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Front_ShutdownStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_front_shutdown_status_unpack(
    struct mcb_sens_front_shutdown_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Front_ShutdownStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_front_shutdown_status_init(struct mcb_sens_front_shutdown_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_front_shutdown_status_is_shut_closed_pre_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_shutdown_status_is_shut_closed_pre_inertia_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_shutdown_status_is_shut_closed_pre_inertia_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_front_shutdown_status_is_shut_closed_post_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_shutdown_status_is_shut_closed_post_inertia_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_shutdown_status_is_shut_closed_post_inertia_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_front_shutdown_status_is_shut_closed_post_bots_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_shutdown_status_is_shut_closed_post_bots_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_shutdown_status_is_shut_closed_post_bots_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_sens_front_shutdown_status_is_shut_closed_post_cockpit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_shutdown_status_is_shut_closed_post_cockpit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_shutdown_status_is_shut_closed_post_cockpit_is_in_range(int8_t value);

/**
 * Pack message BMSLV_RelayOverride.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_relay_override_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_relay_override_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_RelayOverride.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_relay_override_unpack(
    struct mcb_bmslv_relay_override_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_RelayOverride.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_relay_override_init(struct mcb_bmslv_relay_override_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_relay_override_password_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_relay_override_password_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_relay_override_password_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_relay_override_close_relay_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_relay_override_close_relay_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_relay_override_close_relay_is_in_range(uint8_t value);

/**
 * Pack message BMSLV_CellVoltage1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_cell_voltage1_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_cell_voltage1_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_CellVoltage1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_cell_voltage1_unpack(
    struct mcb_bmslv_cell_voltage1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_CellVoltage1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_cell_voltage1_init(struct mcb_bmslv_cell_voltage1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage1_cell_1_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage1_cell_1_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage1_cell_1_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage1_cell_2_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage1_cell_2_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage1_cell_2_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage1_cell_3_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage1_cell_3_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage1_cell_3_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage1_cell_4_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage1_cell_4_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage1_cell_4_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message BMSLV_CellVoltage2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_cell_voltage2_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_cell_voltage2_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_CellVoltage2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_cell_voltage2_unpack(
    struct mcb_bmslv_cell_voltage2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_CellVoltage2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_cell_voltage2_init(struct mcb_bmslv_cell_voltage2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage2_cell_5_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage2_cell_5_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage2_cell_5_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage2_cell_6_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage2_cell_6_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage2_cell_6_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_cell_voltage2_cell_7_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_cell_voltage2_cell_7_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_cell_voltage2_cell_7_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message BMSLV_BatteryPackGeneral.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_battery_pack_general_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_battery_pack_general_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_BatteryPackGeneral.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_battery_pack_general_unpack(
    struct mcb_bmslv_battery_pack_general_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_BatteryPackGeneral.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_battery_pack_general_init(struct mcb_bmslv_battery_pack_general_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_battery_pack_general_current_sensor_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_battery_pack_general_current_sensor_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_battery_pack_general_current_sensor_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_battery_pack_general_lv_total_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_battery_pack_general_lv_total_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_battery_pack_general_lv_total_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_battery_pack_general_lv_total_voltage_sum_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_battery_pack_general_lv_total_voltage_sum_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_battery_pack_general_lv_total_voltage_sum_m_v_is_in_range(uint16_t value);

/**
 * Pack message BMSLV_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_status_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_status_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_status_unpack(
    struct mcb_bmslv_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_status_init(struct mcb_bmslv_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_is_relay_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_is_relay_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_is_relay_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell1_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell1_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell1_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell2_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell2_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell2_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell3_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell3_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell3_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell4_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell4_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell4_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell5_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell5_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell5_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell6_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell6_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell6_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell7_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell7_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell7_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell1_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell1_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell1_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell2_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell2_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell2_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell3_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell3_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell3_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell4_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell4_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell4_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell5_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell5_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell5_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell6_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell6_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell6_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_cell7_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_cell7_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_cell7_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp1_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp1_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp1_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp2_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp2_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp2_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp3_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp3_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp3_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp4_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp4_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp4_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp5_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp5_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp5_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp6_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp6_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp6_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp7_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp7_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp7_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp8_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp8_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp8_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp9_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp9_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp9_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp10_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp10_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp10_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp11_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp11_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp11_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bmslv_status_temp12_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_status_temp12_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_status_temp12_ot_is_in_range(uint8_t value);

/**
 * Pack message BMSLV_Temp1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_temp1_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_temp1_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_Temp1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_temp1_unpack(
    struct mcb_bmslv_temp1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_Temp1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_temp1_init(struct mcb_bmslv_temp1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp1_ntc1_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp1_ntc1_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp1_ntc1_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp1_ntc2_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp1_ntc2_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp1_ntc2_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp1_ntc3_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp1_ntc3_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp1_ntc3_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp1_ntc4_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp1_ntc4_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp1_ntc4_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp1_ntc5_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp1_ntc5_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp1_ntc5_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp1_ntc6_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp1_ntc6_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp1_ntc6_resistance_is_in_range(uint16_t value);

/**
 * Pack message BMSLV_Temp2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bmslv_temp2_pack(
    uint8_t *dst_p,
    const struct mcb_bmslv_temp2_t *src_p,
    size_t size);

/**
 * Unpack message BMSLV_Temp2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bmslv_temp2_unpack(
    struct mcb_bmslv_temp2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMSLV_Temp2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bmslv_temp2_init(struct mcb_bmslv_temp2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp2_ntc1_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp2_ntc1_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp2_ntc1_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp2_ntc2_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp2_ntc2_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp2_ntc2_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp2_ntc3_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp2_ntc3_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp2_ntc3_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp2_ntc4_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp2_ntc4_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp2_ntc4_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp2_ntc5_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp2_ntc5_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp2_ntc5_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bmslv_temp2_ntc6_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bmslv_temp2_ntc6_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bmslv_temp2_ntc6_resistance_is_in_range(uint16_t value);

/**
 * Pack message Sens_Front_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_front_3_pack(
    uint8_t *dst_p,
    const struct mcb_sens_front_3_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Front_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_front_3_unpack(
    struct mcb_sens_front_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Front_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_front_3_init(struct mcb_sens_front_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_3_straingauge_push_fr_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_3_straingauge_push_fr_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_3_straingauge_push_fr_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_3_straingauge_tie_fr_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_3_straingauge_tie_fr_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_3_straingauge_tie_fr_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_3_straingauge_push_fl_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_3_straingauge_push_fl_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_3_straingauge_push_fl_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_3_straingauge_tie_fl_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_3_straingauge_tie_fl_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_3_straingauge_tie_fl_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message Sens_Rear_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_rear_3_pack(
    uint8_t *dst_p,
    const struct mcb_sens_rear_3_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Rear_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_rear_3_unpack(
    struct mcb_sens_rear_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Rear_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_rear_3_init(struct mcb_sens_rear_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_3_straingauge_push_rr_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_3_straingauge_push_rr_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_3_straingauge_push_rr_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_3_straingauge_tie_rr_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_3_straingauge_tie_rr_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_3_straingauge_tie_rr_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_3_straingauge_push_rl_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_3_straingauge_push_rl_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_3_straingauge_push_rl_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_3_straingauge_tie_rl_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_3_straingauge_tie_rl_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_3_straingauge_tie_rl_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message dSpace_PeripheralsCTRL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_d_space_peripherals_ctrl_pack(
    uint8_t *dst_p,
    const struct mcb_d_space_peripherals_ctrl_t *src_p,
    size_t size);

/**
 * Unpack message dSpace_PeripheralsCTRL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_d_space_peripherals_ctrl_unpack(
    struct mcb_d_space_peripherals_ctrl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dSpace_PeripheralsCTRL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_d_space_peripherals_ctrl_init(struct mcb_d_space_peripherals_ctrl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_d_space_peripherals_ctrl_brake_light_on_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_d_space_peripherals_ctrl_brake_light_on_ctrl_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_d_space_peripherals_ctrl_brake_light_on_ctrl_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_d_space_peripherals_ctrl_rad_fan_pwm_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_d_space_peripherals_ctrl_rad_fan_pwm_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_d_space_peripherals_ctrl_rad_fan_pwm_ctrl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_d_space_peripherals_ctrl_batt_hv_fan_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_d_space_peripherals_ctrl_batt_hv_fan_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_d_space_peripherals_ctrl_batt_hv_fan_ctrl_is_in_range(uint8_t value);

/**
 * Pack message Sens_Front_NTC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_front_ntc_pack(
    uint8_t *dst_p,
    const struct mcb_sens_front_ntc_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Front_NTC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_front_ntc_unpack(
    struct mcb_sens_front_ntc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Front_NTC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_front_ntc_init(struct mcb_sens_front_ntc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_ntc_ntc_1_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_ntc_ntc_1_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_ntc_ntc_1_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_ntc_ntc_2_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_ntc_ntc_2_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_ntc_ntc_2_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_ntc_ntc_3_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_ntc_ntc_3_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_ntc_ntc_3_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_ntc_ntc_4_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_ntc_ntc_4_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_ntc_ntc_4_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_ntc_ntc_spare1_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_ntc_ntc_spare1_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_ntc_ntc_spare1_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_front_ntc_ntc_spare2_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_front_ntc_ntc_spare2_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_front_ntc_ntc_spare2_resistance_is_in_range(uint16_t value);

/**
 * Pack message Sens_Rear_NTC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_rear_ntc_pack(
    uint8_t *dst_p,
    const struct mcb_sens_rear_ntc_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Rear_NTC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_rear_ntc_unpack(
    struct mcb_sens_rear_ntc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Rear_NTC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_rear_ntc_init(struct mcb_sens_rear_ntc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_ntc_ntc_1_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_ntc_ntc_1_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_ntc_ntc_1_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_ntc_ntc_2_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_ntc_ntc_2_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_ntc_ntc_2_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_ntc_ntc_3_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_ntc_ntc_3_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_ntc_ntc_3_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_ntc_ntc_4_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_ntc_ntc_4_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_ntc_ntc_4_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_ntc_ntc_5_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_ntc_ntc_5_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_ntc_ntc_5_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_ntc_ntc_6_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_ntc_ntc_6_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_ntc_ntc_6_resistance_is_in_range(uint16_t value);

/**
 * Pack message Sens_Rear_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sens_rear_2_pack(
    uint8_t *dst_p,
    const struct mcb_sens_rear_2_t *src_p,
    size_t size);

/**
 * Unpack message Sens_Rear_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sens_rear_2_unpack(
    struct mcb_sens_rear_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Sens_Rear_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sens_rear_2_init(struct mcb_sens_rear_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_2_cooling_pressure_dx_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_2_cooling_pressure_dx_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_2_cooling_pressure_dx_voltage_m_v_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sens_rear_2_cooling_pressure_sx_voltage_m_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sens_rear_2_cooling_pressure_sx_voltage_m_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sens_rear_2_cooling_pressure_sx_voltage_m_v_is_in_range(uint16_t value);

/**
 * Pack message Steering_MotorControl_Debug.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_steering_motor_control_debug_pack(
    uint8_t *dst_p,
    const struct mcb_steering_motor_control_debug_t *src_p,
    size_t size);

/**
 * Unpack message Steering_MotorControl_Debug.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_steering_motor_control_debug_unpack(
    struct mcb_steering_motor_control_debug_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Steering_MotorControl_Debug.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_steering_motor_control_debug_init(struct mcb_steering_motor_control_debug_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_steering_motor_control_debug_front_left_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_steering_motor_control_debug_front_left_on_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_steering_motor_control_debug_front_left_on_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_steering_motor_control_debug_front_right_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_steering_motor_control_debug_front_right_on_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_steering_motor_control_debug_front_right_on_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_steering_motor_control_debug_rear_left_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_steering_motor_control_debug_rear_left_on_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_steering_motor_control_debug_rear_left_on_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mcb_steering_motor_control_debug_rear_right_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_steering_motor_control_debug_rear_right_on_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_steering_motor_control_debug_rear_right_on_is_in_range(int8_t value);


#ifdef __cplusplus
}
#endif

#endif
